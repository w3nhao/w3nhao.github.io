<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://w3nhao.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://w3nhao.github.io//" rel="alternate" type="text/html" /><updated>2023-09-12T21:38:03+08:00</updated><id>https://w3nhao.github.io//feed.xml</id><title type="html">Wenhao Deng</title><subtitle></subtitle><author><name>Wenhao Deng</name><email>wenhao.deng@foxmail.com</email></author><entry><title type="html">Astrophysical Theoretical Framework</title><link href="https://w3nhao.github.io//2023/09/12/Astrophysical-Theoretical-Framework/" rel="alternate" type="text/html" title="Astrophysical Theoretical Framework" /><published>2023-09-12T00:00:00+08:00</published><updated>2023-09-12T00:00:00+08:00</updated><id>https://w3nhao.github.io//2023/09/12/Astrophysical-Theoretical-Framework</id><content type="html" xml:base="https://w3nhao.github.io//2023/09/12/Astrophysical-Theoretical-Framework/"><![CDATA[<hr />

<h2 id="天文物理理论空间-astrophysical-theoretical-framework">天文物理理论空间 (Astrophysical Theoretical Framework)</h2>

<hr />

<h3 id="实体entities">实体（Entities）</h3>

<hr />

<h5 id="天体celestial-objects">天体（Celestial Objects）</h5>

<ul>
  <li><strong>行星（Planets）</strong>
    <ul>
      <li>质量（Mass）</li>
      <li>半径（Radius）</li>
      <li>轨道参数（Orbital Parameters）
        <ul>
          <li>距离（Distance）</li>
          <li>周期（Period）</li>
          <li>偏心率（Eccentricity）</li>
          <li>等等（etc.）</li>
        </ul>
      </li>
      <li>组成（Composition）
        <ul>
          <li>核心（Core）</li>
          <li>地幔（Mantle）</li>
          <li>大气层（Atmosphere）</li>
        </ul>
      </li>
      <li>磁场（Magnetic Field）</li>
      <li>卫星和环（Moons and Rings）</li>
      <li>发现方法（Discovery Method）</li>
    </ul>
  </li>
  <li><strong>卫星（Moons）</strong>
    <ul>
      <li>类似行星的参数（Similar parameters as Planets）</li>
      <li>母行星（Parent Planet）</li>
    </ul>
  </li>
  <li><strong>恒星（Stars）</strong>
    <ul>
      <li>类型（Type）
        <ul>
          <li>主序星（Main Sequence）</li>
          <li>红巨星（Red Giant）</li>
          <li>等等（etc.）</li>
        </ul>
      </li>
      <li>质量（Mass）</li>
      <li>亮度（Luminosity）</li>
      <li>温度（Temperature）</li>
      <li>星体演化阶段（Stellar Evolution Stage）</li>
      <li>核过程（Nuclear Processes）</li>
    </ul>
  </li>
  <li><strong>黑洞（Black Holes）</strong>
    <ul>
      <li>质量（Mass）</li>
      <li>自旋（Spin）</li>
      <li>事件视界半径（Event Horizon Radius）</li>
      <li>霍金辐射（Hawking Radiation, if applicable）</li>
      <li>吸积盘属性（Accretion Disk Properties）</li>
    </ul>
  </li>
  <li><strong>星系（Galaxies）</strong>
    <ul>
      <li>类型（Type）
        <ul>
          <li>螺旋星系（Spiral）</li>
          <li>椭圆星系（Elliptical）</li>
          <li>等等（etc.）</li>
        </ul>
      </li>
      <li>质量（Mass）</li>
      <li>星体数量（Number of Stars）</li>
      <li>星系核心属性（Galactic Core Properties）</li>
      <li>暗物质组成（Dark Matter Composition）</li>
    </ul>
  </li>
  <li><strong>星云（Nebulae）</strong>
    <ul>
      <li>类型（Type）
        <ul>
          <li>行星状星云（Planetary）</li>
          <li>发射星云（Emission）</li>
          <li>等等（etc.）</li>
        </ul>
      </li>
      <li>组成（Composition）
        <ul>
          <li>气体（Gases）</li>
          <li>灰尘（Dust）</li>
        </ul>
      </li>
      <li>星体形成过程（Stellar Formation Processes）</li>
    </ul>
  </li>
  <li><strong>系外行星（Exoplanets）</strong>
    <ul>
      <li>类似行星的参数（Similar parameters as Planets）</li>
      <li>宿主恒星（Host Star）</li>
    </ul>
  </li>
  <li><strong>矮行星（Dwarf Planets）</strong>
    <ul>
      <li>类似行星的参数（Similar parameters as Planets）</li>
    </ul>
  </li>
  <li><strong>彗星/小行星（Comets/Asteroids）</strong>
    <ul>
      <li>质量（Mass）</li>
      <li>组成（Composition）</li>
      <li>轨道参数（Orbital Parameters）
        <ul>
          <li>距离（Distance）</li>
          <li>周期（Period）</li>
          <li>偏心率（Eccentricity）</li>
          <li>等等（etc.）</li>
        </ul>
      </li>
      <li>尾巴特性（Tail Characteristics, for comets）</li>
    </ul>
  </li>
  <li><strong>暗物质/暗能量团簇（Dark Matter/Dark Energy Clusters）</strong>
    <ul>
      <li>估计质量（Estimated Mass）</li>
      <li>可观测效应（Observable Effects）
        <ul>
          <li>弯曲（Lensing）</li>
          <li>等等（etc.）</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>类星体（Quasars）</strong>
    <ul>
      <li>亮度（Luminosity）</li>
      <li>发射光谱（Emission Spectra）</li>
      <li>关联星系（Associated Galaxy）</li>
    </ul>
  </li>
  <li><strong>脉冲星（Pulsars）</strong>
    <ul>
      <li>周期（Period）</li>
      <li>质量（Mass）</li>
      <li>发射类型（Emission Types）
        <ul>
          <li>射电（Radio）</li>
          <li>X射线（X-ray）</li>
          <li>等等（etc.）</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>白矮星（White Dwarfs）</strong>
    <ul>
      <li>质量（Mass）</li>
      <li>温度（Temperature）</li>
      <li>半径（Radius）</li>
    </ul>
  </li>
  <li><strong>超新星（Supernovae）</strong>
    <ul>
      <li>类型（Type）
        <ul>
          <li>Ia</li>
          <li>II</li>
          <li>等等（etc.）</li>
        </ul>
      </li>
      <li>爆炸前星体类型（Pre-explosion Star Type）</li>
      <li>残骸（Remnant）
        <ul>
          <li>黑洞（Black Hole）</li>
          <li>中子星（Neutron Star）</li>
          <li>等等（etc.）</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="物理定律physical-laws">物理定律（Physical Laws）</h4>

<ul>
  <li><strong>牛顿定律（Newton’s Laws）</strong>
    <ul>
      <li>方程式（Equations）</li>
      <li>局限性（Limitations）</li>
    </ul>
  </li>
  <li><strong>热力学定律（Laws of Thermodynamics）</strong>
    <ul>
      <li>方程式（Equations）</li>
      <li>应用（Applications）</li>
    </ul>
  </li>
  <li><strong>守恒定律（Conservation Laws）</strong>
    <ul>
      <li>动量（Momentum）</li>
      <li>能量（Energy）</li>
    </ul>
  </li>
  <li><strong>量子力学（Quantum Mechanics）</strong>
    <ul>
      <li>基础方程式（Fundamental Equations）
        <ul>
          <li>薛定谔方程（Schrodinger Equation）</li>
          <li>等等（etc.）</li>
        </ul>
      </li>
      <li>量子数（Quantum Numbers）</li>
    </ul>
  </li>
  <li><strong>广义和特殊相对论（General and Special Relativity）</strong>
    <ul>
      <li>基础方程式（Fundamental Equations）
        <ul>
          <li>爱因斯坦方程（Einstein’s Equations）</li>
          <li>等等（etc.）</li>
        </ul>
      </li>
      <li>概念（Concepts）
        <ul>
          <li>时空（Spacetime）</li>
          <li>黑洞（Black Holes）</li>
          <li>等等（etc.）</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>电磁学（Electromagnetism）</strong>
    <ul>
      <li>麦克斯韦方程（Maxwell’s Equations）</li>
      <li>应用（Applications）</li>
    </ul>
  </li>
  <li><strong>哈勃定律（Hubble’s Law）</strong>
    <ul>
      <li>方程式（Equation）</li>
      <li>含义（Implications）
        <ul>
          <li>宇宙膨胀（Expanding Universe）</li>
          <li>等等（etc.）</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="理论theories">理论（Theories）</h4>

<ul>
  <li><strong>天体力学（Celestial Mechanics）</strong>
    <ul>
      <li>关键方程式（Key Equations</li>
      <li>应用（Applications）
        <ul>
          <li>轨道（Orbits）</li>
          <li>潮汐力（Tidal Forces）</li>
          <li>等等（etc.）</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>行星科学（Planetary Science）</strong>
    <ul>
      <li>形成理论（Formation Theories）</li>
      <li>气候模型（Climate Models）</li>
    </ul>
  </li>
  <li><strong>星体动力学（Stellar Dynamics）</strong>
    <ul>
      <li>星体演化模型（Stellar Evolution Models）</li>
      <li>核聚变过程（Nuclear Fusion Processes）</li>
    </ul>
  </li>
  <li><strong>宇宙学（Cosmology）</strong>
    <ul>
      <li>大爆炸理论（Big Bang Theory）</li>
      <li>宇宙微波背景（Cosmic Microwave Background）</li>
    </ul>
  </li>
  <li><strong>星系和系外星系天文学（Galactic and Extragalactic Astronomy）</strong>
    <ul>
      <li>星系形成（Galaxy Formation）</li>
      <li>星系团簇（Galactic Clusters）</li>
    </ul>
  </li>
  <li><strong>高能天体物理学（High-Energy Astrophysics）</strong>
    <ul>
      <li>粒子加速（Particle Acceleration）</li>
      <li>伽马射线暴（Gamma-Ray Bursts）</li>
    </ul>
  </li>
  <li><strong>引力物理学（Gravitational Physics）</strong>
    <ul>
      <li>引力波（Gravitational Waves）</li>
      <li>黑洞力学（Black Hole Mechanics）</li>
    </ul>
  </li>
  <li><strong>量子场论（Quantum Field Theory）</strong>
    <ul>
      <li>拉格朗日量（Lagrangians）</li>
      <li>费曼图（Feynman Diagrams）</li>
    </ul>
  </li>
  <li><strong>弦理论（String Theory）</strong>
    <ul>
      <li>基础方程式（Fundamental Equations）</li>
      <li>额外维度（Extra Dimensions）</li>
    </ul>
  </li>
</ul>

<hr />
<h3 id="属性attributes">属性（Attributes）</h3>
<hr />

<ol>
  <li>
    <p><strong>天体（Celestial Objects）</strong></p>

    <ul>
      <li><strong>质量（Mass）</strong>
        <ul>
          <li>静止质量（Rest Mass）</li>
          <li>相对论质量（Relativistic Mass）</li>
        </ul>
      </li>
      <li><strong>密度（Density）</strong>
        <ul>
          <li>平均密度（Mean Density）</li>
          <li>核心密度（Core Density）</li>
          <li>外壳密度（Crust Density）</li>
        </ul>
      </li>
      <li><strong>位置（Position）</strong>
        <ul>
          <li>银河坐标（Galactic Coordinates）</li>
          <li>黄道坐标（Ecliptic Coordinates）</li>
          <li>赤道坐标（Equatorial Coordinates）</li>
          <li>高度-方位坐标（Alt-Az Coordinates）</li>
        </ul>
      </li>
      <li><strong>速度（Velocity）</strong>
        <ul>
          <li>径向速度（Radial Velocity）</li>
          <li>切向速度（Tangential Velocity）</li>
          <li>相对论速度（Relativistic Velocity）</li>
        </ul>
      </li>
      <li><strong>加速度（Acceleration）</strong>
        <ul>
          <li>向心加速度（Centripetal Acceleration）</li>
          <li>切向加速度（Tangential Acceleration）</li>
          <li>重力加速度（Gravitational Acceleration）</li>
        </ul>
      </li>
      <li><strong>温度（Temperature）</strong>
        <ul>
          <li>表面温度（Surface Temperature）</li>
          <li>核心温度（Core Temperature）</li>
          <li>有效温度（Effective Temperature）</li>
        </ul>
      </li>
      <li><strong>化学成分（Chemical Composition）</strong>
        <ul>
          <li>元素丰度（Elemental Abundance: H, He, etc.）</li>
          <li>分子组成（Molecular Composition: H2O, CO2, etc.）</li>
          <li>微量元素（Trace Elements）</li>
        </ul>
      </li>
      <li><strong>半径/大小（Radius/Size）</strong>
        <ul>
          <li>赤道半径（Equatorial Radius）</li>
          <li>极半径（Polar Radius）</li>
          <li>黑洞的Schwarzschild半径（Schwarzschild Radius for Black Holes）</li>
        </ul>
      </li>
      <li><strong>光度（Luminosity）</strong>
        <ul>
          <li>辐射全光度（Bolometric Luminosity）</li>
          <li>光谱光度（Spectral Luminosity）</li>
          <li>视光度（Apparent Luminosity）</li>
        </ul>
      </li>
      <li><strong>自转/角动量（Spin/Angular Momentum）</strong>
        <ul>
          <li>自转速率（Spin Rate）</li>
          <li>自转轴（Spin Axis）</li>
          <li>自转-轨道耦合（Spin-Orbit Coupling）</li>
        </ul>
      </li>
      <li><strong>轨道参数（Orbit Parameters）</strong>
        <ul>
          <li>偏心率（Eccentricity）</li>
          <li>长半轴（Semimajor Axis）</li>
          <li>倾角（Inclination）</li>
          <li>升交点经度（Longitude of Ascending Node）</li>
          <li>近心点幅角（Argument of Periapsis）</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>物理定律（Physical Laws）</strong></p>

    <ul>
      <li><strong>常数（Constants）</strong>
        <ul>
          <li>重力常数（Gravitational Constant, ( G )</li>
          <li>普朗克常数（Planck’s Constant, ( h )</li>
          <li>光速（Speed of Light, ( c )</li>
          <li>基础电荷（Elementary Charge, ( e )</li>
        </ul>
      </li>
      <li><strong>方程（Equations）</strong>
        <ul>
          <li>牛顿定律（Newton’s Laws）</li>
          <li>爱因斯坦场方程（Einstein’s Field Equations）</li>
          <li>薛定谔方程（Schrödinger Equation）</li>
          <li>麦克斯韦方程（Maxwell’s Equations）</li>
        </ul>
      </li>
      <li><strong>适用范围（Domains of Applicability）</strong>
        <ul>
          <li>宏观尺度（Macroscopic Scale）</li>
          <li>量子尺度（Quantum Scale）</li>
          <li>相对论尺度（Relativistic Scale）</li>
          <li>非相对论尺度（Non-relativistic Scale）</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>理论（Theories）</strong></p>

    <ul>
      <li><strong>假设（Assumptions）</strong>
        <ul>
          <li>各向同性宇宙（Isotropic Universe）</li>
          <li>各向同性宇宙（Homogeneous Universe）</li>
          <li>守恒定律（Conservation Laws）</li>
        </ul>
      </li>
      <li><strong>局限性（Limitations）</strong>
        <ul>
          <li>非量子引力效应（Non-Quantum Gravitational Effects）</li>
          <li>奇点（Singularities）</li>
          <li>守恒定律的违反（Violations of Conservation Laws）</li>
        </ul>
      </li>
      <li><strong>数学模型（Mathematical Models）</strong>
        <ul>
          <li>度规张量（Metric Tensors）</li>
          <li>拉格朗日量（Lagrangians）</li>
          <li>哈密顿量（Hamiltonians）</li>
          <li>费曼图（Feynman Diagrams）</li>
        </ul>
      </li>
      <li><strong>预测（Predictions）</strong>
        <ul>
          <li>暗物质（Dark Matter）</li>
          <li>暗能量（Dark Energy）</li>
          <li>多宇宙（Multiverse）</li>
          <li>虫洞（Wormholes）</li>
        </ul>
      </li>
      <li><strong>实证证据（Empirical Evidence, if applicable）</strong>
        <ul>
          <li>观测到的红移（Observed Redshift）</li>
          <li>宇宙微波背景辐射（Cosmic Microwave Background Radiation）</li>
          <li>粒子碰撞数据（Particle Collision Data）</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<hr />
<h3 id="关系relations">关系（Relations）</h3>
<hr />

<h4 id="数学关系mathematical-relations">数学关系（Mathematical Relations）</h4>

<h5 id="1-引力相互作用gravitational-interactions">1. 引力相互作用（Gravitational Interactions）</h5>

<ul>
  <li>牛顿万有引力定律（Newton’s Universal Law of Gravitation）</li>
  <li>爱因斯坦广义相对论方程（Einstein’s General Relativity Equations）</li>
  <li>在引力背景下的泊松方程（Poisson’s Equation in the context of Gravity）</li>
</ul>

<h5 id="2-电磁相互作用electromagnetic-interactions">2. 电磁相互作用（Electromagnetic Interactions）</h5>

<ul>
  <li>麦克斯韦方程组（Maxwell’s Equations）</li>
  <li>洛伦兹力方程（Lorentz Force Equations）</li>
  <li>辐射定律，如普朗克定律和斯特潘-玻尔兹曼定律（Radiation laws like Planck’s law and Stefan-Boltzmann law）</li>
</ul>

<h5 id="3-量子力学quantum-mechanics">3. 量子力学（Quantum Mechanics）</h5>

<ul>
  <li>薛定谔方程（Schrödinger Equation）</li>
  <li>海森堡不确定性原理（Heisenberg Uncertainty Principle）</li>
  <li>量子场论方程（例如，狄拉克方程）（Quantum Field Theory Equations, e.g., Dirac Equation）</li>
</ul>

<h5 id="4-运动方程kinematic-equations">4. 运动方程（Kinematic Equations）</h5>

<ul>
  <li>位置、速度和加速度方程（Position, Velocity, and Acceleration equations）</li>
  <li>守恒定律（例如，动量和能量守恒）（Conservation laws, e.g., momentum, energy）</li>
</ul>

<h5 id="5-热力学关系thermodynamic-relations">5. 热力学关系（Thermodynamic Relations）</h5>

<ul>
  <li>热力学定律（Laws of Thermodynamics）</li>
  <li>状态方程（Equations of State）</li>
  <li>热传递方程（Heat Transfer Equations）</li>
</ul>

<h5 id="6-宇宙学方程cosmological-equations">6. 宇宙学方程（Cosmological Equations）</h5>

<ul>
  <li>弗里德曼方程（Friedmann Equations）</li>
  <li>规模因子方程（Scale Factor equations）</li>
  <li>暗能量方程（Dark Energy equations）</li>
</ul>

<h5 id="7-统计关系statistical-relations">7. 统计关系（Statistical Relations）</h5>

<ul>
  <li>亮度函数（Luminosity Functions）</li>
  <li>星体形成率（Star Formation Rates）</li>
  <li>黑洞熵（Black Hole Entropy）</li>
</ul>

<h4 id="因果关系causal-relations">因果关系（Causal Relations）</h4>

<h5 id="1-星体演化stellar-evolution">1. 星体演化（Stellar Evolution）</h5>

<ul>
  <li>氢燃烧导致氦生成（Hydrogen burning leading to helium）</li>
  <li>核心崩溃导致超新星或黑洞（Core collapse leading to supernovae or black holes）</li>
</ul>

<h5 id="2-行星形成planetary-formation">2. 行星形成（Planetary Formation）</h5>

<ul>
  <li>原行星盘导致行星形成（Protoplanetary disk leading to planet formation）</li>
  <li>冲击事件导致月球形成（Impact events leading to moon formation）</li>
</ul>

<h5 id="3-星系动力学galactic-dynamics">3. 星系动力学（Galactic Dynamics）</h5>

<ul>
  <li>引力相互作用导致星系合并（Gravitational interactions leading to galaxy mergers）</li>
  <li>星体的形成和死亡影响星系结构（Star formation and death affecting galactic structure）</li>
</ul>

<h5 id="4-宇宙学事件cosmological-events">4. 宇宙学事件（Cosmological Events）</h5>

<ul>
  <li>大爆炸导致宇宙微波背景辐射（Big Bang leading to cosmic microwave background radiation）</li>
  <li>暗能量导致宇宙加速膨胀（Dark energy causing accelerated expansion）</li>
</ul>

<h4 id="分层关系hierarchical-relations">分层关系（Hierarchical Relations）</h4>

<h5 id="1-天体层次结构celestial-hierarchy">1. 天体层次结构（Celestial Hierarchy）</h5>

<ul>
  <li>宇宙 &gt; 星系团 &gt; 星系 &gt; 星团 &gt; 行星系统 &gt; 行星 &gt; 卫星（Universe &gt; Galaxy Clusters &gt; Galaxies &gt; Star Clusters &gt; Planetary Systems &gt; Planets &gt; Moons）</li>
</ul>

<h5 id="2-物理定律层次结构physical-laws-hierarchy">2. 物理定律层次结构（Physical Laws Hierarchy）</h5>

<ul>
  <li>基本力（引力，电磁力，强力和弱力）（Fundamental Forces: Gravity, Electromagnetism, Strong and Weak Nuclear Forces）</li>
  <li>派生定律（例如，守恒定律，热力学）（Derived Laws: Conservation Laws, Thermodynamics）</li>
</ul>

<h5 id="3-理论框架theoretical-frameworks">3. 理论框架（Theoretical Frameworks）</h5>

<ul>
  <li>经典物理（牛顿力学，电磁学）（Classical Physics: Newtonian Mechanics, Electromagnetism）</li>
  <li>相对论物理（特殊和广义相对论）（Relativistic Physics: Special and General Relativity）</li>
  <li>量子物理（量子力学，量子场论）（Quantum Physics: Quantum Mechanics, Quantum Field Theory）</li>
  <li>统一理论（弦理论，M理论）（Unified Theories: String Theory, M-Theory）</li>
</ul>

<h5 id="4-数据分类data-classification">4. 数据分类（Data Classification）</h5>

<ul>
  <li>恒星类型（O、B、A、F、G、K、M）（Types of stars: O, B, A, F, G, K, M）</li>
  <li>星系类型（螺旋、椭圆、不规则）（Types of galaxies: Spiral, Elliptical, Irregular）</li>
</ul>

<hr />
<h3 id="逻辑层logic-layer">逻辑层（Logic Layer）</h3>
<hr />

<h4 id="公理axioms">公理（Axioms）</h4>

<ol>
  <li><strong>基本常数不变（Fundamental Constants are Invariant）</strong>
    <ul>
      <li>光速 (c) （Speed of light (c)</li>
      <li>普朗克常数 (h) （Planck’s constant (h)</li>
      <li>引力常数 (G) （Gravitational constant (G)</li>
      <li>精细结构常数 (\alpha) （Fine structure constant (\alpha)</li>
    </ul>
  </li>
  <li><strong>物理定律的普遍性（Universality of Physical Laws）</strong>
    <ul>
      <li>牛顿运动定律 (F = ma)</li>
      <li>广义相对论方程 (G_{\mu\nu} = 8\pi T_{\mu\nu})</li>
      <li>麦克斯韦电磁方程 ( \nabla \cdot \mathbf{E} = \frac{\rho}{\epsilon_0} )</li>
      <li>量子力学（薛定谔方程、海森堡不确定性原理）(i\hbar \frac{\partial}{\partial t} \Psi = \hat{H} \Psi)</li>
    </ul>
  </li>
  <li><strong>因果原则（Causality Principle）</strong>
    <ul>
      <li>因果时间排序 (t_1 &lt; t_2)</li>
      <li>光锥 (ds^2 = -c^2 dt^2 + dx^2 + dy^2 + dz^2)</li>
    </ul>
  </li>
  <li><strong>最小作用原理（Principle of Least Action）</strong>
    <ul>
      <li>欧拉-拉格朗日方程 ( \frac{\partial L}{\partial q_i} - \frac{d}{dt} \frac{\partial L}{\partial \dot{q}_i} = 0 )</li>
      <li>哈密顿原理 ( \delta \int_{t_1}^{t_2} L(q_i, \dot{q}_i, t) dt = 0 )</li>
      <li>孟普尔图伊原理 ( \delta \int_{t_1}^{t_2} \sqrt{g_{\mu\nu} \dot{x}^\mu \dot{x}^\nu} dt = 0 )</li>
    </ul>
  </li>
  <li><strong>守恒定律成立（Conservation Laws Hold）</strong>
    <ul>
      <li>能量 (E = mc^2)</li>
      <li>动量 (p = mv)</li>
      <li>角动量 (L = I \omega)</li>
      <li>电荷 (Q = \int \rho dV)</li>
      <li>重子数 (B = \int \rho_B dV)</li>
      <li>轻子数 (L = \int \rho_L dV)</li>
    </ul>
  </li>
  <li><strong>对称原理（Symmetry Principles）</strong>
    <ul>
      <li>洛伦兹对称性 ( \Lambda^\mu_\nu \Lambda^\nu_\rho = \delta^\mu_\rho )</li>
      <li>规范对称 ( \mathcal{L} \rightarrow \mathcal{L} + \partial_\mu \mathcal{F}^\mu )</li>
      <li>宇称  ( \mathcal{L} \rightarrow \mathcal{L} )</li>
      <li>时间反演对称 (t \rightarrow -t)</li>
      <li>电荷共轭对称 ( \psi \rightarrow \psi^c = C \bar{\psi}^T )</li>
      <li>CPT对称</li>
    </ul>
  </li>
  <li><strong>时空的均匀性与各向同性（Homogeneity and Isotropy of Space-Time）</strong>
    <ul>
      <li>宇宙学原理 ( \text{Universe is homogeneous and isotropic} )</li>
      <li>FLRW度规 ( ds^2 = -dt^2 + a^2(t) \left[ \frac{dr^2}{1-kr^2} + r^2 d\Omega^2 \right] )</li>
    </ul>
  </li>
  <li><strong>某些性质的量子化（Quantization of Certain Properties）</strong>
    <ul>
      <li>自旋 (s = \frac{n}{2})</li>
      <li>电荷 (Q = ne)</li>
      <li>原子内能级 (E_n = -\frac{m_e e^4}{2 \hbar^2 n^2})</li>
      <li>量子数（(n, l, m, s)） ( \psi_{n,l,m,s} )</li>
    </ul>
  </li>
  <li><strong>尺度不变性（Scale Invariance）</strong>
    <ul>
      <li>重整化群 ( \mu \frac{\partial}{\partial \mu} \mathcal{L} = 0 )</li>
      <li>缩放定律</li>
      <li>分形</li>
    </ul>
  </li>
  <li><strong>时间不可逆性（Time Irreversibility）</strong>
    <ul>
      <li>时间的箭头 (t_1 &lt; t_2)</li>
      <li>热力学第二定律（熵） (dS \geq 0)</li>
      <li>信息不对称 (I(X;Y) \neq I(Y;X))</li>
    </ul>
  </li>
  <li><strong>量子-经典边界（Quantum-Classical Boundary）</strong>
    <ul>
      <li>普朗克尺度 (l_P = \sqrt{\frac{\hbar G}{c^3}})</li>
      <li>退相干机制 ( \rho_{\text{total}} = \rho_{\text{system}} \otimes \rho_{\text{environment}} )</li>
      <li>对应原理 ( \hbar \rightarrow 0 )</li>
    </ul>
  </li>
  <li><strong>强弱人类原理（Strong and Weak Anthropic Principles）</strong>
    <ul>
      <li>弱人类原理 ( \text{The Universe must be compatible with the existence of observers at some point.} )</li>
      <li>强人类原理 ( \text{The Universe must be compatible with the existence of observers at all points.} )</li>
    </ul>
  </li>
  <li><strong>信息守恒（Information Conservation）</strong>
    <ul>
      <li>在封闭系统内，信息量保持不变 ( \Delta I = 0 )</li>
      <li>黑洞信息悖论 ( \text{Information is lost in black holes.} )</li>
    </ul>
  </li>
  <li><strong>叠加原理（Superposition Principle）</strong>
    <ul>
      <li>对于量子系统，薛定谔方程的任何解的组合也是解 ( \Psi = \sum_i c_i \psi_i )</li>
    </ul>
  </li>
  <li><strong>排斥原理（Exclusion Principle）</strong>
    <ul>
      <li>保利排斥原理：没有两个相同的费米子可以占据相同的量子态 ( \psi(x_1, x_2) = -\psi(x_2, x_1) )</li>
    </ul>
  </li>
  <li><strong>边界条件（Boundary Conditions）</strong>
    <ul>
      <li>影响系统演变的边界条件 ( \psi(x_1, x_2) = 0 )</li>
      <li>狄利克雷、诺伊曼、和罗宾边界条件 ( \psi(x_1, x_2) = 0 )</li>
    </ul>
  </li>
  <li><strong>全息原理（Holographic Principle）</strong>
    <ul>
      <li>一个空间体积的信息可以被认为是编码在该区域的边界上 ( \text{Information of a volume can be thought of as encoded on the boundary of that region.} )</li>
    </ul>
  </li>
</ol>

<hr />

<h4 id="谓词predicates">谓词（Predicates）</h4>

<ol>
  <li><strong>对象X处于状态Y（Object X is in State Y）</strong>
    <ul>
      <li>例如：”行星A处于椭圆轨道。”</li>
    </ul>
  </li>
  <li><strong>定律X适用于系统Y（Law X Applies to System Y）</strong>
    <ul>
      <li>例如：”牛顿引力定律适用于行星系统。”</li>
    </ul>
  </li>
  <li><strong>理论X预测结果Y（Theory X Predicts Outcome Y）</strong>
    <ul>
      <li>例如：”广义相对论预测光绕大质量物体弯曲。”</li>
    </ul>
  </li>
  <li><strong>对象X具有性质Y，其值为Z（Object X has Property Y with Value Z）</strong>
    <ul>
      <li>例如：”恒星A的温度为Y Kelvin。”</li>
    </ul>
  </li>
  <li><strong>对象X受对象Y影响（Object X is Influenced by Object Y）</strong>
    <ul>
      <li>例如：”行星A的轨道受恒星B的影响。”</li>
    </ul>
  </li>
  <li><strong>参数X在范围Y内（Parameter X is Within Range Y）</strong>
    <ul>
      <li>例如：”速度远小于光速。”</li>
    </ul>
  </li>
  <li><strong>陈述X来源于公理Y（Statement X is Derived from Axiom Y）</strong>
    <ul>
      <li>例如：”地球绕太阳旋转的说法来源于牛顿定律。”</li>
    </ul>
  </li>
  <li><strong>理论X与观测Y相符/不符（Theory X Conflicts/Agrees with Observation Y）</strong>
    <ul>
      <li>例如：”大爆炸理论与宇宙微波背景辐射相符。”</li>
    </ul>
  </li>
  <li><strong>对象X由Y组成（Object X is Composed of Y）</strong>
    <ul>
      <li>例如：”恒星A主要由氢和氦组成。”</li>
    </ul>
  </li>
  <li><strong>对象X由于Z沿路径Y运动（Object X Follows Path Y Due to Z）</strong>
    <ul>
      <li>例如：”彗星A由于太阳的引力影响沿椭圆路径运动。”</li>
    </ul>
  </li>
  <li><strong>事件X在时间Y发生（Event X Occurred at Time Y）</strong>
    <ul>
      <li>例如：”超新星A在时间T爆炸。”</li>
    </ul>
  </li>
  <li><strong>现象X具有概率Y（Phenomenon X has Probability Y）</strong>
    <ul>
      <li>例如：”粒子A有50%的概率穿过屏障。”</li>
    </ul>
  </li>
  <li><strong>系统X处于平衡/非平衡状态（System X is in Equilibrium/Non-Equilibrium）</strong>
    <ul>
      <li>例如：”星系团A处于热平衡状态。”</li>
    </ul>
  </li>
  <li><strong>对象X通过力Z与对象Y交互（Object X Interacts with Object Y through Force Z）</strong>
    <ul>
      <li>例如：”地球通过引力与月球交互。”</li>
    </ul>
  </li>
  <li><strong>对象X演变成状态Y（Object X Evolves into State Y）</strong>
    <ul>
      <li>例如：”恒星A演变成红巨星。”</li>
    </ul>
  </li>
  <li><strong>在条件Z下，理论X取代理论Y（Theory X Supersedes Theory Y under Conditions Z）</strong>
    <ul>
      <li>例如：”对于具有强重力场的物体，广义相对论取代牛顿力学。”</li>
    </ul>
  </li>
  <li><strong>现象X通过方法Y可观察（Phenomenon X is Observable Through Method Y）</strong>
    <ul>
      <li>例如：”暗物质通过其对可见物质的引力效应可观察。”</li>
    </ul>
  </li>
</ol>

<hr />

<h4 id="推理规则rules-of-inference">推理规则（Rules of Inference）</h4>

<ol>
  <li><strong>假言推理（Modus Ponens）</strong>: 如果 ( P )，那么 ( Q )。 ( P ) 是真的，因此 ( Q ) 是真的。</li>
  <li><strong>拒言推理（Modus Tollens）</strong>: 如果 ( P )，那么 ( Q )。不 ( Q )，因此不 ( P )。</li>
  <li><strong>链推理（Chain Rule）</strong>: 如果 ( P )，那么 ( Q )。如果 ( Q )，那么 ( R )。因此，如果 ( P )，那么 ( R )。</li>
  <li><strong>析取推理（Disjunctive Syllogism）</strong>: ( P ) 或 ( Q )。不 ( P )，因此 ( Q )。</li>
  <li><strong>全称概括（Universal Generalization）</strong>: 如果对任意 ( X ) 都成立，那么对所有 ( X ) 都成立。</li>
  <li><strong>全称特指（Universal Instantiation）</strong>: 如果对所有 ( X ) 都成立，那么对任意特定的 ( X ) 都成立。</li>
  <li><strong>存在性概括（Existential Generalization）</strong>: 如果对某个特定的 ( X ) 成立，那么对某些 ( X ) 成立。</li>
  <li><strong>存在性特指（Existential Instantiation）</strong>: 如果对某些 ( X ) 成立，那么我们可以推断对至少一个特定的 ( X ) 成立。</li>
  <li><strong>反证法（Reductio ad Absurdum）</strong>: 如果假设非 ( P ) 导致矛盾，那么 ( P ) 必须是真的。</li>
  <li><strong>条件推理（Hypothetical Syllogism）</strong>: 如果 ( P ) 导致 ( Q ) 并且 ( Q ) 导致 ( R )，那么 ( P ) 导致 ( R )。</li>
  <li><strong>肯定结论（Affirming the Consequent）</strong>: 通常被认为是谬误，但可以作为对比（如果 ( P )，那么 ( Q )。 ( Q ) 是真的，因此 ( P ) 必须是真的）。</li>
  <li><strong>否定前提（Denying the Antecedent）</strong>: 另一个谬误，可以作为对比（如果 ( P )，那么 ( Q )。不 ( P )，因此不 ( Q )）。</li>
  <li><strong>概率假言推理（Probabilistic Modus Ponens）</strong>: 如果 ( P )，那么 ( Q ) 具有一定的概率。观察到 ( P )，因此 ( Q ) 具有一定的概率为真。</li>
  <li><strong>反事实推理（Counterfactual Reasoning）</strong>: 如果 ( P ) 曾经是真的，( Q ) 就会是真的。</li>
  <li><strong>归因推理（Abduction）</strong>: 给定观察 ( Q )，假设 ( P ) 是最佳解释。</li>
  <li><strong>类比推理（Argument from Analogy）</strong>: 如果 ( P ) 对 ( X ) 是真的并且 ( P ) 对 ( Y ) 是真的，那么 ( Q ) 对 ( X ) 是真的则暗示 ( Q ) 对 ( Y ) 很可能是真的。</li>
</ol>

<hr />

<h4 id="逻辑连接词logic-connectors">逻辑连接词（Logic Connectors）</h4>

<ol>
  <li><strong>与（AND）</strong>: 合取</li>
  <li><strong>或（OR）</strong>: 析取</li>
  <li><strong>非（NOT）</strong>: 否定</li>
  <li><strong>蕴含（IMPLIES）</strong>: 条件</li>
  <li><strong>当且仅当（IFF）</strong>: 双条件</li>
  <li><strong>异或（XOR）</strong>: ( P ) 或 ( Q )，但不同时成立。</li>
  <li><strong>与非（NAND）</strong>: 不同时 ( P ) 和 ( Q )。</li>
  <li><strong>或非（NOR）</strong>: 既非 ( P ) 也非 ( Q )。</li>
  <li><strong>当且仅当非（IFFN）</strong>: 双条件否定。</li>
  <li><strong>等价非（XNOR）</strong>: 等价运算，与XOR相反。</li>
  <li><strong>蕴含非（IMPLYNOT）</strong>: 条件否定，如果 ( P ) 那么非 ( Q )。</li>
</ol>

<hr />

<h2 id="ask-gpt-4">Ask GPT-4</h2>

<p><strong>Question:</strong> Given the System of Astronomy Theoretical Space (Entities, Attributes, Relations, Logic Layer), please use the first-logic combining the logic layer to make a hypothesis that explains the perturbation in orbit of Uranus.</p>

<p><strong>Answer:</strong>
To explain the perturbation in the orbit of Uranus using first-order logic and the given Astronomy Theoretical Space, we can incorporate entities, attributes, relations, and axioms from the logic layer. Here’s how to frame it:</p>

<h3 id="entities">Entities</h3>
<ul>
  <li>Uranus (a planet)</li>
  <li>Neptune (another planet, initially unknown)</li>
  <li>Sun (a star)</li>
</ul>

<h3 id="attributes">Attributes</h3>
<ul>
  <li>Mass of Uranus, Neptune, and Sun</li>
  <li>Orbital parameters of Uranus (and Neptune)</li>
  <li>Position of Uranus, Neptune, and Sun at various times</li>
  <li>Gravitational constant (G)</li>
</ul>

<h3 id="relations">Relations</h3>
<ul>
  <li>Gravitational interactions between celestial bodies</li>
  <li>Theoretical frameworks (Newtonian Mechanics, General Relativity)</li>
</ul>

<h3 id="axioms">Axioms</h3>
<ol>
  <li>( \text{Universality of Physical Laws: Newton’s law of gravitation applies to planetary systems.} )</li>
  <li>( \text{Fundamental Constants are Invariant: The gravitational constant G is the same throughout the observable universe.} )</li>
  <li>( \text{Causality Principle: Effects follow causes.} )</li>
</ol>

<h3 id="hypothesis-formulation">Hypothesis Formulation</h3>

<ol>
  <li><strong>Observation</strong>: The orbit of Uranus shows perturbations that cannot be explained solely by the known planets and Newton’s law of gravitation.
    <ul>
      <li>( \text{OrbitPerturbation}(Uranus) )</li>
    </ul>
  </li>
  <li><strong>Gravitational Law</strong>: According to Newton’s law of gravitation, any two masses attract each other with a force ( F = \frac ).
    <ul>
      <li>( \text{GravitationalForce}(Uranus, X) )</li>
    </ul>
  </li>
  <li><strong>Unknown Mass Hypothesis</strong>: There exists an unknown object (Neptune) whose gravitational influence explains the observed perturbations in the orbit of Uranus.
    <ul>
      <li>( \exists X (\text{CelestialObject}(X) \land \text{GravitationalForce}(Uranus, X) \land \text{ExplainsPerturbation}(X, Uranus)) )</li>
    </ul>
  </li>
  <li><strong>Causality</strong>: If the gravitational interaction with the unknown object (Neptune) exists, then it is the cause of the observed perturbations.
    <ul>
      <li>( \text{GravitationalForce}(Uranus, X) \rightarrow \text{OrbitPerturbation}(Uranus) )</li>
    </ul>
  </li>
  <li><strong>Universality of Laws</strong>: Newton’s law of gravitation should be applicable to Uranus and the unknown object (Neptune), as it is a universal law.
    <ul>
      <li>( \text{ApplicableLaw}(NewtonGravity, Uranus, X) )</li>
    </ul>
  </li>
</ol>

<h3 id="complete-hypothesis-in-first-order-logic">Complete Hypothesis in First-Order Logic</h3>
<p>[
\text{OrbitPerturbation}(Uranus) \land \text{ApplicableLaw}(NewtonGravity, Uranus, X) \rightarrow \exists X (\text{CelestialObject}(X) \land \text{GravitationalForce}(Uranus, X) \land \text{ExplainsPerturbation}(X, Uranus))
]</p>

<p>This hypothesis suggests that if there are observed perturbations in the orbit of Uranus and Newton’s law of gravitation is applicable, then there exists an unknown celestial object (which we now know as Neptune) whose gravitational force explains these perturbations.</p>

<p>Note: This is a simplified representation and assumes that only gravitational interactions are responsible for the perturbations. In a more detailed model, other forces and factors might also be considered.</p>]]></content><author><name>Wenhao Deng</name><email>wenhao.deng@foxmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">HR, NDCG, and MRR: An easy implementation with TorchMetrics</title><link href="https://w3nhao.github.io//2023/03/31/HR-MRR-NDCG-Torchmetric-Implementation/" rel="alternate" type="text/html" title="HR, NDCG, and MRR: An easy implementation with TorchMetrics" /><published>2023-03-31T00:00:00+08:00</published><updated>2023-03-31T00:00:00+08:00</updated><id>https://w3nhao.github.io//2023/03/31/HR-MRR-NDCG-Torchmetric-Implementation</id><content type="html" xml:base="https://w3nhao.github.io//2023/03/31/HR-MRR-NDCG-Torchmetric-Implementation/"><![CDATA[<p>To assess the performance of  Recommender systems, we need to have reliable evaluation metrics. In this blog post, we will discuss three popular metrics: Hit Rate (HR), Normalized Discounted Cumulative Gain (NDCG), and Mean Reciprocal Rank (MRR). We will also show you how to easily implement these metrics using TorchMetrics and integrate them into a PyTorch Lightning model.</p>

<h2 id="0-understanding-the-get_topk_ranks-function">0. Understanding the <code class="language-plaintext highlighter-rouge">get_topk_ranks</code> Function</h2>

<p>In the context of our recommender system evaluation, it is essential to understand the <code class="language-plaintext highlighter-rouge">get_topk_ranks</code> function, which plays a crucial role in computing the ranks of the target items in the predicted scores. This function is used as an intermediate step to calculate the HR, NDCG, and MRR metrics.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_topk_ranks</span><span class="p">(</span><span class="n">pred_scores</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">topk</span><span class="p">):</span>
    <span class="s">""" get topk ranks of the target in the pred_scores
    Args:
        pred_scores: (batch_size, item_num(with padding item))
        target: (batch_size, ) or (batch_size, 1)
        topk: int
        
    Returns:
        topk_rank: (batch_size, 1) topk + 1 if not hit, 1 is the first rank
    """</span>
    <span class="k">assert</span> <span class="n">target</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">pred_scores</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">pred_scores</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">topk</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">target</span><span class="p">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">target</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">topk_idx</span> <span class="o">=</span> <span class="n">pred_scores</span><span class="p">.</span><span class="nf">topk</span><span class="p">(</span><span class="n">topk</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">hitted_row</span><span class="p">,</span> <span class="n">rank</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">topk_idx</span><span class="p">).</span><span class="nf">nonzero</span><span class="p">().</span><span class="nf">split</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rank</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c1"># first set all rank to maximum value 
</span>    <span class="c1"># int64 or set all rank to topk + 1
</span>    <span class="n">all_rank</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">full_like</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">topk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># then set the hitted row to the rank
</span>    <span class="n">all_rank</span> <span class="o">=</span> <span class="n">all_rank</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hitted_row</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">all_rank</span>
</code></pre></div></div>

<h3 id="the-get_topk_ranks-function-explained">The <code class="language-plaintext highlighter-rouge">get_topk_ranks</code> Function Explained</h3>

<p>The <code class="language-plaintext highlighter-rouge">get_topk_ranks</code> function takes three arguments: <code class="language-plaintext highlighter-rouge">pred_scores</code>, <code class="language-plaintext highlighter-rouge">target</code>, and <code class="language-plaintext highlighter-rouge">topk</code>. It returns the ranks of the target items within the top-k predictions.</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">pred_scores</code>: A tensor of shape <code class="language-plaintext highlighter-rouge">(batch_size, item_num(with padding item))</code>, representing the predicted scores for each item for all users in a batch.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">target</code>: A tensor of shape <code class="language-plaintext highlighter-rouge">(batch_size,)</code> or <code class="language-plaintext highlighter-rouge">(batch_size, 1)</code>, containing the ground truth target items for each user in the batch.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">topk</code>: An integer value representing the number of top items we want to consider.</p>
  </li>
</ol>

<p>The function returns a tensor <code class="language-plaintext highlighter-rouge">topk_rank</code> of shape <code class="language-plaintext highlighter-rouge">(batch_size, 1)</code> containing the top-k ranks of the target items in the predicted scores. If a target item is not in the top-k predictions, the rank will be set to <code class="language-plaintext highlighter-rouge">topk + 1</code>.</p>

<h3 id="how-the-get_topk_ranks-function-works">How the <code class="language-plaintext highlighter-rouge">get_topk_ranks</code> Function Works</h3>

<p>The <code class="language-plaintext highlighter-rouge">get_topk_ranks</code> function follows these steps to compute the ranks:</p>

<ol>
  <li>
    <p>Ensures that the target tensor has two dimensions by unsqueezing it if necessary.</p>
  </li>
  <li>
    <p>Retrieves the indices of the top-k items in the predicted scores using the <code class="language-plaintext highlighter-rouge">topk()</code> method.</p>
  </li>
  <li>
    <p>Computes the ranks of the target items within the top-k predictions by checking if the target item is present in the top-k indices.</p>
  </li>
  <li>
    <p>Initializes a tensor <code class="language-plaintext highlighter-rouge">all_rank</code> with the same shape as the target tensor, filled with the value <code class="language-plaintext highlighter-rouge">topk + 1</code>.</p>
  </li>
  <li>
    <p>Updates the <code class="language-plaintext highlighter-rouge">all_rank</code> tensor with the computed ranks for each user using the <code class="language-plaintext highlighter-rouge">scatter()</code> method.</p>
  </li>
</ol>

<p>By using the <code class="language-plaintext highlighter-rouge">get_topk_ranks</code> function, we can efficiently compute the top-k ranks for each user in a batch, which is an essential step for calculating HR, NDCG, and MRR metrics in our recommender system evaluation.</p>

<h2 id="1-hit-rate-hr">1. Hit Rate (HR)</h2>

<p>Hit Rate is a simple and intuitive metric that measures the proportion of relevant items recommended to the user.</p>

<p><strong>Mathematical Definition:</strong></p>

<p>HR@k = (Number of hits in the top-k recommendations) / (Total number of recommendations)</p>

<p>The Hit Ratio (HR) is a binary metric that measures whether a relevant item is present in the top-k recommendations or not. Mathematically, it can be expressed as:</p>

<p>$$\text{HR@k} = \frac{1}{|U|}\sum_{u=1}^{|U|} \text{hit}_u
$$</p>

<p>
where $|U|$ is the number of users, and $\text{hit}_u$ is 1 if the ground truth item is present in the top-k recommendations for user $u$, and 0 otherwise.
</p>

<p><strong>TorchMetrics Implementation:</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">torchmetrics</span> <span class="kn">import</span> <span class="n">Metric</span>

<span class="k">class</span> <span class="nc">HR</span><span class="p">(</span><span class="n">Metric</span><span class="p">):</span>
    <span class="p">...</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">topk_rank</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">accumulate_count</span> <span class="o">+=</span> <span class="n">topk_rank</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">accumulate_metric</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_metric</span><span class="p">(</span><span class="n">topk_rank</span><span class="p">[</span><span class="n">topk_rank</span> <span class="o">&lt;=</span> <span class="n">self</span><span class="p">.</span><span class="n">k</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_metric</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">topk_rank</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">topk_rank</span><span class="p">.</span><span class="nf">numel</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="2-normalized-discounted-cumulative-gain-ndcg">2. Normalized Discounted Cumulative Gain (NDCG)</h2>
<p>NDCG is a metric that measures the quality of the ranking of the recommended items, taking into account their relevance and position in the list.</p>

<p><strong>Mathematical Definition:</strong></p>

<p>Normalized Discounted Cumulative Gain (NDCG) is a measure that evaluates the quality of the ranking of recommended items. It takes into account the positions of relevant items in the top-k recommendations. The NDCG@k is defined as:</p>

<p>NDCG@k = (DCG@k) / (IDCG@k)</p>

<p>where DCG@k is the Discounted Cumulative Gain at position k, and IDCG@k is the Ideal Discounted Cumulative Gain at position k.</p>

<p>DCG@k = sum(relevance_i / log2(i + 1)) for i in range(1, k + 1)</p>

<p>$$\text{NDCG@k} = \frac{1}{|U|} \sum_{u=1}^{|U|} \frac{\sum_{i=1}^{k} \frac{2^{\text{rel}_i(u)} - 1}{\log_2{(i+1)}}}{\text{IDCG}_u}
$$</p>

<p>
where $|U|$ is the number of users, $\text{rel}_i(u)$ is the relevance score of item $i$ for user $u$, and $\text{IDCG}_u$ is the Ideal Discounted Cumulative Gain for user $u$, which is the maximum possible NDCG for that user.
</p>

<p><strong>TorchMetrics Implementation:</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">torchmetrics</span> <span class="kn">import</span> <span class="n">Metric</span>

<span class="k">class</span> <span class="nc">NDCG</span><span class="p">(</span><span class="n">Metric</span><span class="p">):</span>
    <span class="p">...</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">topk_rank</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">accumulate_count</span> <span class="o">+=</span> <span class="n">topk_rank</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">accumulate_metric</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_metric</span><span class="p">(</span><span class="n">topk_rank</span><span class="p">[</span><span class="n">topk_rank</span> <span class="o">&lt;=</span> <span class="n">self</span><span class="p">.</span><span class="n">k</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_metric</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">topk_rank</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">torch</span><span class="p">.</span><span class="nf">log2</span><span class="p">(</span><span class="n">topk_rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="3-mean-reciprocal-rank-mrr">3. Mean Reciprocal Rank (MRR)</h2>
<p>MRR is a metric that measures the quality of the ranking of the recommended items by computing the average of the reciprocal ranks of the first relevant item in the list.</p>

<p><strong>Mathematical Definition:</strong></p>

<p>Mean Reciprocal Rank (MRR) is another metric that evaluates the ranking quality of recommended items. It is the average of the reciprocal of the rank of the first relevant item in the top-k recommendations for each user. MRR can be defined as:</p>

<p>MRR@k = (1 / Number of users) * sum(1 / rank_i) for i in range(Number of users)</p>

<p>$$\text{MRR@k} = \frac{1}{|U|}\sum_{u=1}^{|U|} \frac{1}{\text{rank}_u}
$$</p>

<p>
where $|U|$ is the number of users, and $\text{rank}_u$ is the position of the first relevant item in the top-k recommendations for user $u$.
</p>

<p><strong>TorchMetrics Implementation:</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">torchmetrics</span> <span class="kn">import</span> <span class="n">Metric</span>

<span class="k">class</span> <span class="nc">MRR</span><span class="p">(</span><span class="n">Metric</span><span class="p">):</span>
    <span class="p">...</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">topk_rank</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">accumulate_count</span> <span class="o">+=</span> <span class="n">topk_rank</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">accumulate_metric</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_metric</span><span class="p">(</span><span class="n">topk_rank</span><span class="p">[</span><span class="n">topk_rank</span> <span class="o">&lt;=</span> <span class="n">self</span><span class="p">.</span><span class="n">k</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_metric</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">topk_rank</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">topk_rank</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="integrating-metrics-with-pytorch-lightning">Integrating Metrics with PyTorch Lightning</h2>
<p>Now, let’s demonstrate how to integrate these evaluation metrics into a PyTorch Lightning model using a sample recommender system called SASRec.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pytorch_lightning</span> <span class="k">as</span> <span class="n">pl</span>
<span class="kn">from</span> <span class="n">torchmetrics</span> <span class="kn">import</span> <span class="n">MetricCollection</span>

<span class="k">class</span> <span class="nc">SASRec</span><span class="p">(</span><span class="n">pl</span><span class="p">.</span><span class="n">LightningModule</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="p">...):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="p">...</span>
        <span class="n">self</span><span class="p">.</span><span class="n">topk_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">topk_metric</span> <span class="o">=</span> <span class="n">MetricCollection</span>
        <span class="p">({</span>
            <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">metric_name</span><span class="si">}</span><span class="s">@</span><span class="si">{</span><span class="n">topk</span><span class="si">}</span><span class="s">"</span><span class="p">:</span> <span class="nf">globals</span><span class="p">()[</span><span class="n">metric_name</span><span class="p">](</span><span class="n">topk</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">metric_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s">"HR"</span><span class="p">,</span> <span class="s">"NDCG"</span><span class="p">,</span> <span class="s">"MRR"</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">topk</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">topk_list</span>
        <span class="p">})</span>

    <span class="k">def</span> <span class="nf">_on_val_test_epoch_start</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">topk</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">topk_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">metric_name</span> <span class="ow">in</span> <span class="n">METRIC_LIST</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">topk_metric</span><span class="p">[</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">metric_name</span><span class="si">}</span><span class="s">@</span><span class="si">{</span><span class="n">topk</span><span class="si">}</span><span class="s">"</span><span class="p">].</span><span class="nf">reset</span><span class="p">()</span>

        <span class="n">self</span><span class="p">.</span><span class="nf">register_buffer</span><span class="p">(</span>
            <span class="s">"all_item_embs"</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">item_encoder</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">all_item_ids</span><span class="p">),</span> <span class="n">persistent</span><span class="o">=</span><span class="bp">False</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_validation_epoch_start</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_on_val_test_epoch_start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_test_epoch_start</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_on_val_test_epoch_start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_val_test_step</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">stage</span><span class="p">):</span>
        <span class="p">...</span>

        <span class="n">pred_item_embs</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">forward</span><span class="p">(</span><span class="n">input_ids</span><span class="p">,</span> <span class="n">input_mask</span><span class="p">)</span>
        <span class="n">pred_scores</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">pred_item_embs</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">all_item_embs</span><span class="p">.</span><span class="nf">t</span><span class="p">()).</span><span class="nf">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pred_scores</span> <span class="o">=</span> <span class="n">pred_scores</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">history</span><span class="p">,</span> <span class="o">-</span><span class="nf">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">))</span>

        <span class="n">target</span> <span class="o">=</span> <span class="n">behavs</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">topk</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">topk_list</span><span class="p">)</span>
        <span class="n">all_ranks</span> <span class="o">=</span> <span class="nf">get_topk_ranks</span><span class="p">(</span><span class="n">pred_scores</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">topk</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">topk</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">topk_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">metric_name</span> <span class="ow">in</span> <span class="n">METRIC_LIST</span><span class="p">:</span>
                <span class="n">metric</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">topk_metric</span><span class="p">[</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">metric_name</span><span class="si">}</span><span class="s">@</span><span class="si">{</span><span class="n">topk</span><span class="si">}</span><span class="s">"</span><span class="p">]</span>
                <span class="n">metric</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">all_ranks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">validation_step</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_val_test_step</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="s">"val"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_step</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_val_test_step</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="s">"test"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_val_test_epoch_end</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">stage</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">topk</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">topk_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">metric_name</span> <span class="ow">in</span> <span class="n">METRIC_LIST</span><span class="p">:</span>
                <span class="n">score</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">topk_metric</span><span class="p">[</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">metric_name</span><span class="si">}</span><span class="s">@</span><span class="si">{</span><span class="n">topk</span><span class="si">}</span><span class="s">"</span><span class="p">].</span><span class="nf">compute</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">metric_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s">"HR"</span><span class="p">,</span> <span class="s">"NDCG"</span><span class="p">]</span> <span class="ow">and</span> <span class="n">topk</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">]:</span>
                    <span class="n">log_on_progress_bar</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">log_on_progress_bar</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">self</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">stage</span><span class="si">}</span><span class="s">_</span><span class="si">{</span><span class="n">metric_name</span><span class="si">}</span><span class="s">@</span><span class="si">{</span><span class="n">topk</span><span class="si">}</span><span class="s">"</span><span class="p">,</span>
                         <span class="n">score</span><span class="p">,</span>
                         <span class="n">on_epoch</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                         <span class="n">prog_bar</span><span class="o">=</span><span class="n">log_on_progress_bar</span><span class="p">,</span>
                         <span class="n">logger</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                         <span class="n">sync_dist</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">self</span><span class="p">.</span><span class="n">all_item_embs</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">validation_epoch_end</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_val_test_epoch_end</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="s">"val"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_epoch_end</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_val_test_epoch_end</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="s">"test"</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="next-steps-experimenting-with-recommender-systems">Next Steps: Experimenting with Recommender Systems</h2>

<p>After implementing and integrating these evaluation metrics into your PyTorch Lightning model, you can use them to gauge the performance of your recommender system. Additionally, you can employ these metrics to compare different models and decide which one is best suited for your application.</p>]]></content><author><name>Wenhao Deng</name><email>wenhao.deng@foxmail.com</email></author><summary type="html"><![CDATA[To assess the performance of Recommender systems, we need to have reliable evaluation metrics. In this blog post, we will discuss three popular metrics: Hit Rate (HR), Normalized Discounted Cumulative Gain (NDCG), and Mean Reciprocal Rank (MRR). We will also show you how to easily implement these metrics using TorchMetrics and integrate them into a PyTorch Lightning model.]]></summary></entry><entry><title type="html">Limitation of ChatGPT in Causal Inference</title><link href="https://w3nhao.github.io//2023/03/30/Limitation-ChatGPT-Causal-Inference/" rel="alternate" type="text/html" title="Limitation of ChatGPT in Causal Inference" /><published>2023-03-30T00:00:00+08:00</published><updated>2023-03-30T00:00:00+08:00</updated><id>https://w3nhao.github.io//2023/03/30/Limitation-ChatGPT-Causal-Inference</id><content type="html" xml:base="https://w3nhao.github.io//2023/03/30/Limitation-ChatGPT-Causal-Inference/"><![CDATA[<p>In the realm of artificial intelligence, the ability to understand and reason about causality has always been a significant challenge. In a recent exchange on Twitter, Turing Prize Laureate Judea Pearl and AI enthusiast Jim Fan discussed the limitations of GPT, a state-of-the-art language model, in inferring causal relationships.</p>

<p><img src="\../public/img/tweet_screen_shot_20230331.png#pic_center# =200x200" alt="img" />
<a href="https://twitter.com/yudapearl/status/1641386266595033088">tweet_link</a></p>

<h2 id="judea-pearls-critique">Judea Pearl’s Critique</h2>
<p>According to Judea Pearl, deep learning models like GPT are inherently limited in their ability to reason about causality. He argues that their achievements amount to little more than “curve fitting” and are constrained by the passive data they are trained on. Pearl posits that answering causal questions requires either causal assumptions or interventional experiments to enrich the data.</p>

<h2 id="jim-fans-perspective">Jim Fan’s Perspective</h2>
<p>Jim Fan, on the other hand, highlights GPT’s impressive performance in reasoning about “why” (cause and effect) and “what if” (counterfactual imagination). He suggests that GPT’s ability to infer causality could be attributed to:</p>

<ul>
  <li>The presence of causal examples and counterfactuals in the pre-training data.</li>
  <li>Inductive reasoning based on common sense.</li>
  <li>Language pattern matching.</li>
  <li>Heuristics applied to novel cases.</li>
</ul>

<h2 id="the-inherent-limitations-of-gpt">The Inherent Limitations of GPT</h2>
<p>While GPT demonstrates some ability to reason about causality, it is important to recognize its inherent limitations. As an AI language model, GPT is unable to directly manipulate variables or actively collect new data to validate its causal inferences. Instead, it relies on the causal assumptions and human judgments present in its training data.</p>

<p>One example of this limitation can be seen in a hypothetical scenario where GPT is trained on a dataset containing the false statement: “Jumping from a building won’t kill you because it’s from the tenth floor.” In this case, GPT might take this erroneous story as a causal assumption and generate incorrect inferences when answering related questions. Since GPT lacks the ability to interact with the real world and conduct interventional experiments, it cannot validate or correct its understanding of the causal relationship.</p>

<h2 id="a-cautious-approach-to-causal-inference">A Cautious Approach to Causal Inference</h2>
<p>In light of these limitations, it is essential to exercise caution when using GPT or similar models for causal inference. To obtain more accurate results, it may be necessary to combine GPT’s output with correct causal assumptions or conduct interventional experiments where possible.</p>

<p>In conclusion, the dialogue between Judea Pearl and Jim Fan serves as a valuable reminder of the limitations of deep learning models like GPT in the domain of causal inference. While these models have made significant strides in various aspects of natural language understanding, their abilities in causal reasoning remain constrained by their training data and the algorithms themselves.</p>

<hr />

<font color="LightSlateGray" size="5" face="Times">GPT在因果推理方面的局限性：Judea Pearl和Jim Fan的对话</font>

<p>在人工智能领域，理解和推理因果关系一直是一个重要的挑战。最近，在Twitter上，图灵奖得主Judea Pearl和人工智能爱好者Jim Fan就GPT这一最先进的语言模型在推断因果关系方面的局限性进行了讨论。</p>

<p>Judea Pearl的批评</p>

<p>据Judea Pearl称，像GPT这样的深度学习模型在推理因果关系方面存在内在的局限性。他认为，这些模型的成就只不过是“曲线拟合”，并受到它们所训练的被动数据的限制。Pearl认为，回答因果问题需要因果假设或干预实验来丰富数据。</p>

<p>Jim Fan的观点</p>

<p>另一方面，Jim Fan强调了GPT在推理“为什么”（因果关系）和“如果”（反事实想象）方面的卓越表现。他认为，GPT推断因果关系的能力可以归因于：</p>

<ul>
  <li>预训练数据中存在因果示例和反事实条件。</li>
  <li>基于常识的归纳推理。</li>
  <li>语言模式匹配。</li>
  <li>应用于新情况的启发式方法。</li>
</ul>

<p>GPT的内在局限性</p>

<p>尽管GPT在因果推理方面表现出一定的能力，但我们仍需认识到其内在的局限性。作为一种人工智能语言模型，GPT无法直接操纵变量或主动收集新数据以验证其因果推断。相反，它依赖于训练数据中的因果假设和人类判断。</p>

<p>这种局限性的一个例子是，在一个假设的场景中，GPT接受了一个包含错误陈述的数据集：“跳楼不会死，因为跳的是十楼。” 在这种情况下，GPT可能会将这个错误的故事作为因果假设，并在回答相关问题时产生错误的推断。由于GPT缺乏与现实世界互动和进行干预实验的能力，它无法验证或纠正其对因果关系的理解。</p>

<p>小心谨慎地进行因果推理</p>

<p>鉴于这些局限性，在使用GPT或类似模型进行因果推理时，必须小心谨慎。为了获得更准确的结果，可能需要将GPT的输出与正确的因果假设相结合，或在可能的情况下进行干预实验。</p>

<p>总之，Judea Pearl和Jim Fan之间的对话为我们提醒了深度学习模型如GPT在因果推理领域的局限性。虽然这些模型在自然语言理解的各个方面取得了重要进展，但它们在因果推理能力方面仍受到训练数据和算法本身的限制。</p>]]></content><author><name>Wenhao Deng</name><email>wenhao.deng@foxmail.com</email></author><summary type="html"><![CDATA[In the realm of artificial intelligence, the ability to understand and reason about causality has always been a significant challenge. In a recent exchange on Twitter, Turing Prize Laureate Judea Pearl and AI enthusiast Jim Fan discussed the limitations of GPT, a state-of-the-art language model, in inferring causal relationships.]]></summary></entry><entry><title type="html">Falsificationism and Bayesianism</title><link href="https://w3nhao.github.io//2023/03/29/Falsificationism-and-Bayesianism/" rel="alternate" type="text/html" title="Falsificationism and Bayesianism" /><published>2023-03-29T00:00:00+08:00</published><updated>2023-03-29T00:00:00+08:00</updated><id>https://w3nhao.github.io//2023/03/29/Falsificationism-and-Bayesianism</id><content type="html" xml:base="https://w3nhao.github.io//2023/03/29/Falsificationism-and-Bayesianism/"><![CDATA[<!-- English Content Start -->

<p>Philosophy of science is a discipline that studies the nature, methods, categories, and knowledge structure of science. Among them, falsificationism and Bayesianism are two important philosophical views on science, which emphasize different reasoning methods and evidence verification methods.</p>

<h2 id="falsificationism">Falsificationism</h2>

<p>Falsificationism is a philosophical view on science proposed by the philosopher Karl Popper [1]. Falsificationism holds that scientific theories should be falsifiable, and scientists should try to prove a theory wrong rather than seek evidence to support it. Falsificationism emphasizes the importance of critically testing scientific theories.</p>

<p>However, falsificationism also has some limitations. Firstly, falsificationism tends to emphasize deductive reasoning while neglecting the importance of inductive reasoning in science. Secondly, the simplification of the relationship between theory and observation by falsificationism may lead to misunderstandings. Observational data may be influenced by many factors, and experimental results usually depend on the scientific instruments and technologies used. In addition, falsificationism advocates abandoning a theory when it is sufficiently falsified. However, in practical scientific practice, it is difficult to determine when a theory has been sufficiently falsified. Therefore, the application of falsificationism also needs to consider uncertainty and complexity.</p>

<h2 id="bayesianism">Bayesianism</h2>

<p>Compared to falsificationism, Bayesianism tries to save inductive reasoning and provides another perspective. Bayesianism, based on Bayes’ theorem, quantifies beliefs by calculating probabilities as the basis for reasoning and decision-making. They believe that new evidence updates our beliefs about a proposition or hypothesis, and these beliefs are adjusted according to Bayes’ theorem.</p>

<p>The specific ways in which Bayesianism saves inductive reasoning include using prior probabilities, updating beliefs, and probability reasoning [2]. However, Bayesianism also faces some criticisms, such as subjectivity, computational complexity, model selection, and overfitting problems [3].</p>

<h2 id="comparison-of-the-two-views">Comparison of the Two Views</h2>

<p>Falsificationism and Bayesianism are two different philosophical views on science, which emphasize different reasoning methods and evidence verification methods. Compared to falsificationism, Bayesianism pays more attention to uncertainty and complexity and tries to handle these problems through quantifying beliefs and probability calculations.</p>

<p>The comparison of the two views can be carried out from the following aspects:</p>

<h3 id="reasoning-methods">Reasoning Methods</h3>

<p>Falsificationism emphasizes deductive reasoning, that is, deriving specific conclusions from general principles, and emphasizes finding counterexamples from observational data to prove a theory wrong. Bayesianism is more concerned with inductive reasoning, that is, deriving general principles from specific situations and updating beliefs based on new evidence.</p>

<h3 id="evidence-verification">Evidence Verification</h3>

<p>Falsificationism holds that a theory should only be abandoned when it is sufficiently falsified by evidence. Bayesianism holds that any new evidence should be used to update prior beliefs and adjust posterior beliefs according to Bayes’ theorem.</p>

<h3 id="handling-uncertainty">Handling Uncertainty</h3>

<p>Falsificationism handles uncertainty relatively simply, that is, falsifying a theory based on observational data. Bayesianism pays more attention to quantifying uncertainty and tries to handle uncertainty and complexity problems through probability calculations.</p>

<h3 id="limitations">Limitations</h3>

<p>The limitations of falsificationism include neglecting the role of inductive reasoning in science and the problem of the relationship between theory and observation. The limitations of Bayesianism include subjectivity, computational complexity, model selection, and overfitting problems.</p>

<h1 id="conclusion">Conclusion</h1>

<p>Falsificationism and Bayesianism are two different philosophical views on science, which emphasize different reasoning methods and evidence verification methods. Although falsificationism has some limitations, it emphasizes the importance of critically testing scientific theories and is an important part of the philosophy of science. Bayesianism pays more attention to uncertainty and complexity and tries to handle these problems through quantifying beliefs and probability calculations, which has broad application value in practical use.</p>

<h1 id="references">References</h1>
<p>[1] Popper, K. R. (1959). The logic of scientific discovery. Routledge.</p>

<p>[2] Jaynes, E. T. (2003). Probability theory: The logic of science. Cambridge University Press.</p>

<p>[3] Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari, A., &amp; Rubin, D. B. (2013). Bayesian data analysis (3rd ed.). Chapman and Hall/CRC.</p>

<!-- English Content End -->
<!-- Chinese Content Start -->

<hr />

<font color="LightSlateGray" size="5" face="Times">证伪主义与贝叶斯主义：科学哲学的两种观点</font>

<p>科学哲学是研究科学本质、方法、范畴和知识结构的哲学学科。其中，证伪主义和贝叶斯主义是两种重要的科学哲学观点，它们分别强调了不同的推理方式和证据检验方法。</p>

<p>证伪主义</p>

<p>证伪主义是由哲学家卡尔·波普尔提出的一种科学哲学观点。证伪主义认为科学理论应该是可证伪的，而科学家应该尝试证明一个理论是错误的，而不是寻找支持这个理论的证据。证伪主义强调了对科学理论进行批判性检验的重要性。</p>

<p>然而，证伪主义也存在一些局限性。首先，证伪主义倾向于强调演绎推理，而忽略了归纳推理在科学中的重要性。其次，证伪主义对于理论与观察之间关系的简化可能会导致误解。观察数据可能受到许多因素的影响，而且实验结果通常依赖于所使用的科学仪器和技术。此外，证伪主义提倡在理论受到足够证伪证据的情况下舍弃它。然而，在实际科学实践中，很难确定一个理论何时已经被充分证伪。因此，证伪主义的应用也需要考虑不确定性和复杂性。</p>

<p>贝叶斯主义</p>

<p>相对于证伪主义，贝叶斯主义者尝试挽救归纳主义，提供了另一种观点。贝叶斯主义者基于贝叶斯定理，通过计算概率来量化信念，以此作为推理和决策的基础。他们认为，新的证据会更新我们对某一命题或假设的信念，并根据贝叶斯定理调整这些信念。</p>

<p>贝叶斯主义者挽救归纳主义的具体方式包括使用先验概率、更新信念、概率论证等。然而，贝叶斯主义也面临一些批评，如主观性问题、计算复杂性、模型选择和过拟合问题等。</p>

<p>两种观点的比较</p>

<p>证伪主义和贝叶斯主义是两种不同的科学哲学观点，它们分别强调了不同的推理方式和证据检验方法。相对于证伪主义，贝叶斯主义更加注重不确定性和复杂性，并试图通过量化信念和概率计算来处理这些问题。</p>

<p>两种观点的比较可以从以下几个方面进行：</p>

<p>推理方式</p>

<p>证伪主义强调演绎推理，即从一般原则推导出特定结论，强调从观察数据中寻找反例来证明一个理论是错误的。而贝叶斯主义则更注重归纳推理，即从特定情况推导出一般原则，并根据新证据来更新信念。</p>

<p>证据检验</p>

<p>证伪主义认为，一个理论只有在受到充分证伪证据时才应该被舍弃。而贝叶斯主义认为，任何新证据都应该被用来更新先验信念，并根据贝叶斯定理来调整后验信念。</p>

<p>处理不确定性</p>

<p>证伪主义对于不确定性的处理较为简单，即通过观察数据来证伪一个理论。而贝叶斯主义则更注重量化不确定性，并试图通过概率计算来处理不确定性和复杂性问题。</p>

<p>局限性</p>

<p>证伪主义的局限性包括忽略了归纳推理在科学中的作用，以及理论与观察之间的关系问题等。贝叶斯主义的局限性则包括主观性问题、计算复杂性、模型选择和过拟合问题等。</p>

<p>总结</p>

<p>证伪主义和贝叶斯主义是两种不同的科学哲学观点，它们分别强调了不同的推理方式和证据检验方法。虽然证伪主义存在一些局限性，但它强调了对科学理论进行批判性检验的重要性，是科学哲学中的一个重要组成部分。贝叶斯主义则更注重不确定性和复杂性，并试图通过量化信念和概率计算来处理这些问题，在实际应用中具有广泛的应用价值。</p>]]></content><author><name>Wenhao Deng</name><email>wenhao.deng@foxmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry></feed>