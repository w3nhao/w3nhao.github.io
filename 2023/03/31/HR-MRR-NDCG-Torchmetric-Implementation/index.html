<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      HR, NDCG, and MRR: An easy implementation with TorchMetrics Â· Wenhao Deng
    
  </title>

  
  <link rel="canonical" href="https://w3nhao.github.io/2023/03/31/HR-MRR-NDCG-Torchmetric-Implementation/">
  

  <link rel="stylesheet" href="https://w3nhao.github.io/public/css/poole.css?v=1.1.0">
  <link rel="stylesheet" href="https://w3nhao.github.io/public/css/syntax.css?v=1.1.0">
  <link rel="stylesheet" href="https://w3nhao.github.io/public/css/lanyon.css?v=1.1.0">
  <link rel="stylesheet" href="https://w3nhao.github.io/public/css/dark-mode.css?v=1.1.0">
  <link rel="stylesheet" href="https://w3nhao.github.io/public/css/bottom-nav.css?v=1.1.0">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://w3nhao.github.io/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="https://w3nhao.github.io/public/favicon.ico">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://w3nhao.github.io/atom.xml">

  

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.0/css/all.min.css" crossorigin="anonymous">

  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <script>
    // Check local storage for theme preference and set immediately
    const currentTheme = localStorage.getItem('theme');
    if (currentTheme) {
      document.documentElement.setAttribute('data-theme', currentTheme);
    }
  </script>
  
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const images = document.querySelectorAll(".gallery-item img");
      images.forEach((img) => {
        img.setAttribute("loading", "lazy");
      });
    });
  </script>

  <!-- Simple Vertical Gallery Scripts -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Lazy load images for performance
    const images = document.querySelectorAll('.photo-item img');
    images.forEach(img => {
        img.setAttribute('loading', 'lazy');
    });
    
    console.log('Vertical gallery initialized');
});
</script> 

<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>



  <body>

    <!-- Sidebar removed -->

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
      <div class="wrap">
      <!-- Masthead removed - using bottom nav instead -->
        

      <div class="container content">
        <div class="post">
  <h1 class="post-title">HR, NDCG, and MRR: An easy implementation with TorchMetrics</h1>
  <span class="post-date">31 Mar 2023</span>
  <span class="post-subtitle">Evaluation Metrics for Recommender Systems with PyTorch Lightning: HR, NDCG, and MRR</span>
  

  <button id="toggle-toc" class="toc-button">ðŸ“– Toggle Table of Contents</button>

  <div id="toc-container" class="article-toc">
    <ul id="toc" class="toc__list">
<li class="toc__item toc-h2">
<a href="#0-understanding-the-get_topk_ranks-function">0. Understanding the get_topk_ranks Function</a>
<ul class="toc__sublist">
<li class="toc__item toc-h3"><a href="#the-get_topk_ranks-function-explained">The get_topk_ranks Function Explained</a></li>
<li class="toc__item toc-h3"><a href="#how-the-get_topk_ranks-function-works">How the get_topk_ranks Function Works</a></li>
</ul>
</li>
<li class="toc__item toc-h2"><a href="#1-hit-rate-hr">1. Hit Rate (HR)</a></li>
<li class="toc__item toc-h2"><a href="#2-normalized-discounted-cumulative-gain-ndcg">2. Normalized Discounted Cumulative Gain (NDCG)</a></li>
<li class="toc__item toc-h2"><a href="#3-mean-reciprocal-rank-mrr">3. Mean Reciprocal Rank (MRR)</a></li>
<li class="toc__item toc-h2"><a href="#integrating-metrics-with-pytorch-lightning">Integrating Metrics with PyTorch Lightning</a></li>
<li class="toc__item toc-h2"><a href="#next-steps-experimenting-with-recommender-systems">Next Steps: Experimenting with Recommender Systems</a></li>
</ul>
  </div>

  <p>To assess the performance of  Recommender systems, we need to have reliable evaluation metrics. In this blog post, we will discuss three popular metrics: Hit Rate (HR), Normalized Discounted Cumulative Gain (NDCG), and Mean Reciprocal Rank (MRR). We will also show you how to easily implement these metrics using TorchMetrics and integrate them into a PyTorch Lightning model.</p>

<h2 id="0-understanding-the-get_topk_ranks-function">0. Understanding the <code class="language-plaintext highlighter-rouge">get_topk_ranks</code> Function</h2>

<p>In the context of our recommender system evaluation, it is essential to understand the <code class="language-plaintext highlighter-rouge">get_topk_ranks</code> function, which plays a crucial role in computing the ranks of the target items in the predicted scores. This function is used as an intermediate step to calculate the HR, NDCG, and MRR metrics.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_topk_ranks</span><span class="p">(</span><span class="n">pred_scores</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">topk</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s"> get topk ranks of the target in the pred_scores
    Args:
        pred_scores: (batch_size, item_num(with padding item))
        target: (batch_size, ) or (batch_size, 1)
        topk: int
        
    Returns:
        topk_rank: (batch_size, 1) topk + 1 if not hit, 1 is the first rank
    </span><span class="sh">"""</span>
    <span class="k">assert</span> <span class="n">target</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">pred_scores</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">pred_scores</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">topk</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">target</span><span class="p">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">target</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">topk_idx</span> <span class="o">=</span> <span class="n">pred_scores</span><span class="p">.</span><span class="nf">topk</span><span class="p">(</span><span class="n">topk</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">hitted_row</span><span class="p">,</span> <span class="n">rank</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">topk_idx</span><span class="p">).</span><span class="nf">nonzero</span><span class="p">().</span><span class="nf">split</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rank</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c1"># first set all rank to maximum value 
</span>    <span class="c1"># int64 or set all rank to topk + 1
</span>    <span class="n">all_rank</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">full_like</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">topk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># then set the hitted row to the rank
</span>    <span class="n">all_rank</span> <span class="o">=</span> <span class="n">all_rank</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hitted_row</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">all_rank</span>
</code></pre></div></div>

<h3 id="the-get_topk_ranks-function-explained">The <code class="language-plaintext highlighter-rouge">get_topk_ranks</code> Function Explained</h3>

<p>The <code class="language-plaintext highlighter-rouge">get_topk_ranks</code> function takes three arguments: <code class="language-plaintext highlighter-rouge">pred_scores</code>, <code class="language-plaintext highlighter-rouge">target</code>, and <code class="language-plaintext highlighter-rouge">topk</code>. It returns the ranks of the target items within the top-k predictions.</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">pred_scores</code>: A tensor of shape <code class="language-plaintext highlighter-rouge">(batch_size, item_num(with padding item))</code>, representing the predicted scores for each item for all users in a batch.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">target</code>: A tensor of shape <code class="language-plaintext highlighter-rouge">(batch_size,)</code> or <code class="language-plaintext highlighter-rouge">(batch_size, 1)</code>, containing the ground truth target items for each user in the batch.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">topk</code>: An integer value representing the number of top items we want to consider.</p>
  </li>
</ol>

<p>The function returns a tensor <code class="language-plaintext highlighter-rouge">topk_rank</code> of shape <code class="language-plaintext highlighter-rouge">(batch_size, 1)</code> containing the top-k ranks of the target items in the predicted scores. If a target item is not in the top-k predictions, the rank will be set to <code class="language-plaintext highlighter-rouge">topk + 1</code>.</p>

<h3 id="how-the-get_topk_ranks-function-works">How the <code class="language-plaintext highlighter-rouge">get_topk_ranks</code> Function Works</h3>

<p>The <code class="language-plaintext highlighter-rouge">get_topk_ranks</code> function follows these steps to compute the ranks:</p>

<ol>
  <li>
    <p>Ensures that the target tensor has two dimensions by unsqueezing it if necessary.</p>
  </li>
  <li>
    <p>Retrieves the indices of the top-k items in the predicted scores using the <code class="language-plaintext highlighter-rouge">topk()</code> method.</p>
  </li>
  <li>
    <p>Computes the ranks of the target items within the top-k predictions by checking if the target item is present in the top-k indices.</p>
  </li>
  <li>
    <p>Initializes a tensor <code class="language-plaintext highlighter-rouge">all_rank</code> with the same shape as the target tensor, filled with the value <code class="language-plaintext highlighter-rouge">topk + 1</code>.</p>
  </li>
  <li>
    <p>Updates the <code class="language-plaintext highlighter-rouge">all_rank</code> tensor with the computed ranks for each user using the <code class="language-plaintext highlighter-rouge">scatter()</code> method.</p>
  </li>
</ol>

<p>By using the <code class="language-plaintext highlighter-rouge">get_topk_ranks</code> function, we can efficiently compute the top-k ranks for each user in a batch, which is an essential step for calculating HR, NDCG, and MRR metrics in our recommender system evaluation.</p>

<h2 id="1-hit-rate-hr">1. Hit Rate (HR)</h2>

<p>Hit Rate is a simple and intuitive metric that measures the proportion of relevant items recommended to the user.</p>

<p><strong>Mathematical Definition:</strong></p>

<p>HR@k = (Number of hits in the top-k recommendations) / (Total number of recommendations)</p>

<p>The Hit Ratio (HR) is a binary metric that measures whether a relevant item is present in the top-k recommendations or not. Mathematically, it can be expressed as:</p>

<p>$$\text{HR@k} = \frac{1}{|U|}\sum_{u=1}^{|U|} \text{hit}_u
$$</p>

<p>
where $|U|$ is the number of users, and $\text{hit}_u$ is 1 if the ground truth item is present in the top-k recommendations for user $u$, and 0 otherwise.
</p>

<p><strong>TorchMetrics Implementation:</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">torchmetrics</span> <span class="kn">import</span> <span class="n">Metric</span>

<span class="k">class</span> <span class="nc">HR</span><span class="p">(</span><span class="n">Metric</span><span class="p">):</span>
    <span class="bp">...</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">topk_rank</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">accumulate_count</span> <span class="o">+=</span> <span class="n">topk_rank</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">accumulate_metric</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_metric</span><span class="p">(</span><span class="n">topk_rank</span><span class="p">[</span><span class="n">topk_rank</span> <span class="o">&lt;=</span> <span class="n">self</span><span class="p">.</span><span class="n">k</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_metric</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">topk_rank</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">topk_rank</span><span class="p">.</span><span class="nf">numel</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="2-normalized-discounted-cumulative-gain-ndcg">2. Normalized Discounted Cumulative Gain (NDCG)</h2>
<p>NDCG is a metric that measures the quality of the ranking of the recommended items, taking into account their relevance and position in the list.</p>

<p><strong>Mathematical Definition:</strong></p>

<p>Normalized Discounted Cumulative Gain (NDCG) is a measure that evaluates the quality of the ranking of recommended items. It takes into account the positions of relevant items in the top-k recommendations. The NDCG@k is defined as:</p>

<p>NDCG@k = (DCG@k) / (IDCG@k)</p>

<p>where DCG@k is the Discounted Cumulative Gain at position k, and IDCG@k is the Ideal Discounted Cumulative Gain at position k.</p>

<p>DCG@k = sum(relevance_i / log2(i + 1)) for i in range(1, k + 1)</p>

<p>$$\text{NDCG@k} = \frac{1}{|U|} \sum_{u=1}^{|U|} \frac{\sum_{i=1}^{k} \frac{2^{\text{rel}_i(u)} - 1}{\log_2{(i+1)}}}{\text{IDCG}_u}
$$</p>

<p>
where $|U|$ is the number of users, $\text{rel}_i(u)$ is the relevance score of item $i$ for user $u$, and $\text{IDCG}_u$ is the Ideal Discounted Cumulative Gain for user $u$, which is the maximum possible NDCG for that user.
</p>

<p><strong>TorchMetrics Implementation:</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">torchmetrics</span> <span class="kn">import</span> <span class="n">Metric</span>

<span class="k">class</span> <span class="nc">NDCG</span><span class="p">(</span><span class="n">Metric</span><span class="p">):</span>
    <span class="bp">...</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">topk_rank</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">accumulate_count</span> <span class="o">+=</span> <span class="n">topk_rank</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">accumulate_metric</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_metric</span><span class="p">(</span><span class="n">topk_rank</span><span class="p">[</span><span class="n">topk_rank</span> <span class="o">&lt;=</span> <span class="n">self</span><span class="p">.</span><span class="n">k</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_metric</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">topk_rank</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">torch</span><span class="p">.</span><span class="nf">log2</span><span class="p">(</span><span class="n">topk_rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="3-mean-reciprocal-rank-mrr">3. Mean Reciprocal Rank (MRR)</h2>
<p>MRR is a metric that measures the quality of the ranking of the recommended items by computing the average of the reciprocal ranks of the first relevant item in the list.</p>

<p><strong>Mathematical Definition:</strong></p>

<p>Mean Reciprocal Rank (MRR) is another metric that evaluates the ranking quality of recommended items. It is the average of the reciprocal of the rank of the first relevant item in the top-k recommendations for each user. MRR can be defined as:</p>

<p>MRR@k = (1 / Number of users) * sum(1 / rank_i) for i in range(Number of users)</p>

<p>$$\text{MRR@k} = \frac{1}{|U|}\sum_{u=1}^{|U|} \frac{1}{\text{rank}_u}
$$</p>

<p>
where $|U|$ is the number of users, and $\text{rank}_u$ is the position of the first relevant item in the top-k recommendations for user $u$.
</p>

<p><strong>TorchMetrics Implementation:</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">torchmetrics</span> <span class="kn">import</span> <span class="n">Metric</span>

<span class="k">class</span> <span class="nc">MRR</span><span class="p">(</span><span class="n">Metric</span><span class="p">):</span>
    <span class="bp">...</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">topk_rank</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">accumulate_count</span> <span class="o">+=</span> <span class="n">topk_rank</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">accumulate_metric</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_metric</span><span class="p">(</span><span class="n">topk_rank</span><span class="p">[</span><span class="n">topk_rank</span> <span class="o">&lt;=</span> <span class="n">self</span><span class="p">.</span><span class="n">k</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_metric</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">topk_rank</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">topk_rank</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="integrating-metrics-with-pytorch-lightning">Integrating Metrics with PyTorch Lightning</h2>
<p>Now, let's demonstrate how to integrate these evaluation metrics into a PyTorch Lightning model using a sample recommender system called SASRec.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pytorch_lightning</span> <span class="k">as</span> <span class="n">pl</span>
<span class="kn">from</span> <span class="n">torchmetrics</span> <span class="kn">import</span> <span class="n">MetricCollection</span>

<span class="k">class</span> <span class="nc">SASRec</span><span class="p">(</span><span class="n">pl</span><span class="p">.</span><span class="n">LightningModule</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="p">...):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="bp">...</span>
        <span class="n">self</span><span class="p">.</span><span class="n">topk_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">topk_metric</span> <span class="o">=</span> <span class="n">MetricCollection</span>
        <span class="p">({</span>
            <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">metric_name</span><span class="si">}</span><span class="s">@</span><span class="si">{</span><span class="n">topk</span><span class="si">}</span><span class="sh">"</span><span class="p">:</span> <span class="nf">globals</span><span class="p">()[</span><span class="n">metric_name</span><span class="p">](</span><span class="n">topk</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">metric_name</span> <span class="ow">in</span> <span class="p">[</span><span class="sh">"</span><span class="s">HR</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">NDCG</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">MRR</span><span class="sh">"</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">topk</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">topk_list</span>
        <span class="p">})</span>

    <span class="k">def</span> <span class="nf">_on_val_test_epoch_start</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">topk</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">topk_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">metric_name</span> <span class="ow">in</span> <span class="n">METRIC_LIST</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">topk_metric</span><span class="p">[</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">metric_name</span><span class="si">}</span><span class="s">@</span><span class="si">{</span><span class="n">topk</span><span class="si">}</span><span class="sh">"</span><span class="p">].</span><span class="nf">reset</span><span class="p">()</span>

        <span class="n">self</span><span class="p">.</span><span class="nf">register_buffer</span><span class="p">(</span>
            <span class="sh">"</span><span class="s">all_item_embs</span><span class="sh">"</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">item_encoder</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">all_item_ids</span><span class="p">),</span> <span class="n">persistent</span><span class="o">=</span><span class="bp">False</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_validation_epoch_start</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_on_val_test_epoch_start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_test_epoch_start</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_on_val_test_epoch_start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_val_test_step</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">stage</span><span class="p">):</span>
        <span class="bp">...</span>

        <span class="n">pred_item_embs</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">forward</span><span class="p">(</span><span class="n">input_ids</span><span class="p">,</span> <span class="n">input_mask</span><span class="p">)</span>
        <span class="n">pred_scores</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">pred_item_embs</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">all_item_embs</span><span class="p">.</span><span class="nf">t</span><span class="p">()).</span><span class="nf">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pred_scores</span> <span class="o">=</span> <span class="n">pred_scores</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">history</span><span class="p">,</span> <span class="o">-</span><span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">))</span>

        <span class="n">target</span> <span class="o">=</span> <span class="n">behavs</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">topk</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">topk_list</span><span class="p">)</span>
        <span class="n">all_ranks</span> <span class="o">=</span> <span class="nf">get_topk_ranks</span><span class="p">(</span><span class="n">pred_scores</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">topk</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">topk</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">topk_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">metric_name</span> <span class="ow">in</span> <span class="n">METRIC_LIST</span><span class="p">:</span>
                <span class="n">metric</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">topk_metric</span><span class="p">[</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">metric_name</span><span class="si">}</span><span class="s">@</span><span class="si">{</span><span class="n">topk</span><span class="si">}</span><span class="sh">"</span><span class="p">]</span>
                <span class="n">metric</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">all_ranks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">validation_step</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_val_test_step</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="sh">"</span><span class="s">val</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_step</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_val_test_step</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="sh">"</span><span class="s">test</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_val_test_epoch_end</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">stage</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">topk</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">topk_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">metric_name</span> <span class="ow">in</span> <span class="n">METRIC_LIST</span><span class="p">:</span>
                <span class="n">score</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">topk_metric</span><span class="p">[</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">metric_name</span><span class="si">}</span><span class="s">@</span><span class="si">{</span><span class="n">topk</span><span class="si">}</span><span class="sh">"</span><span class="p">].</span><span class="nf">compute</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">metric_name</span> <span class="ow">in</span> <span class="p">[</span><span class="sh">"</span><span class="s">HR</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">NDCG</span><span class="sh">"</span><span class="p">]</span> <span class="ow">and</span> <span class="n">topk</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">]:</span>
                    <span class="n">log_on_progress_bar</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">log_on_progress_bar</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">self</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">stage</span><span class="si">}</span><span class="s">_</span><span class="si">{</span><span class="n">metric_name</span><span class="si">}</span><span class="s">@</span><span class="si">{</span><span class="n">topk</span><span class="si">}</span><span class="sh">"</span><span class="p">,</span>
                         <span class="n">score</span><span class="p">,</span>
                         <span class="n">on_epoch</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                         <span class="n">prog_bar</span><span class="o">=</span><span class="n">log_on_progress_bar</span><span class="p">,</span>
                         <span class="n">logger</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                         <span class="n">sync_dist</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">self</span><span class="p">.</span><span class="n">all_item_embs</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">validation_epoch_end</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_val_test_epoch_end</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="sh">"</span><span class="s">val</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_epoch_end</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_val_test_epoch_end</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="sh">"</span><span class="s">test</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="next-steps-experimenting-with-recommender-systems">Next Steps: Experimenting with Recommender Systems</h2>

<p>After implementing and integrating these evaluation metrics into your PyTorch Lightning model, you can use them to gauge the performance of your recommender system. Additionally, you can employ these metrics to compare different models and decide which one is best suited for your application.</p>

  
  <!-- Footnotes Script -->
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      const darkModeCheckbox = document.getElementById('dark-mode-checkbox');
  
      // Function to update the tooltip theme
      function updateTooltipTheme(tooltip) {
        const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';
        tooltip.style.backgroundColor = isDarkMode ? '#333' : '#f5f5f5';
        tooltip.style.color = isDarkMode ? '#B0C4DE' : 'black';
        tooltip.style.borderColor = isDarkMode ? '#444' : '#ccc';
      }
  
      darkModeCheckbox.addEventListener('change', function () {
        document.querySelectorAll('.custom-tooltip').forEach(tooltip => {
          updateTooltipTheme(tooltip); // Update tooltips when the theme changes
        });
      });
  
      var footnoteContent = '<hr><h2>Footnotes</h2><ol>';
      document.querySelectorAll('footnote').forEach((element, index) => {
        const key = index + 1;
        const footnoteId = 'fn-' + key;
        const footnoteRefId = 'fnref-' + key;
  
        element.setAttribute('key', key);
        element.setAttribute('id', footnoteRefId);
  
        element.addEventListener('mouseenter', function() {
          const info = this.getAttribute('data-info');
          const postElement = document.querySelector('.post');
          const postWidth = postElement.offsetWidth + 'px';
          const postLeft = postElement.getBoundingClientRect().left;
          const footnoteLeft = this.getBoundingClientRect().left;
  
          const tooltip = document.createElement('div');
          tooltip.classList.add('custom-tooltip');
          tooltip.innerHTML = info;
          tooltip.style.position = 'absolute';
          tooltip.style.left = (postLeft - footnoteLeft) + 'px';
          tooltip.style.bottom = '100%';
          tooltip.style.width = postWidth;
          tooltip.style.borderRadius = '4px';
          tooltip.style.padding = '8px';
          tooltip.style.fontSize = '0.8em';
          tooltip.style.zIndex = '10';
          tooltip.style.whiteSpace = 'pre-wrap';
          tooltip.style.transform = 'translateY(-8px)';
          tooltip.style.transition = 'transform 0.3s ease-in-out, opacity 0.3s ease-in-out';
          tooltip.style.visibility = 'hidden';
          tooltip.style.opacity = '0';
  
          this.appendChild(tooltip);
          updateTooltipTheme(tooltip);
  
          setTimeout(() => {
            tooltip.style.visibility = 'visible';
            tooltip.style.opacity = '1';
          }, 10);
        });
  
        element.addEventListener('mouseleave', function() {
          this.removeChild(this.lastChild);
        });
  
        // Append content for the footnote and add a return link
        var dataInfo = element.getAttribute('data-info');
        footnoteContent += `<li id="${footnoteId}">${dataInfo} <a href="#${footnoteRefId}" title="Return to article">â†©</a></li>`;
      });
      footnoteContent += '</ol>';
  
      // Insert the generated footnotes at the element with id 'footnotes'
      if (document.querySelectorAll('footnote').length > 0) {
        document.getElementById('footnotes').innerHTML = footnoteContent;
      }
    });
  </script>
  
  <!-- Cite References Script -->
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      const cites = document.querySelectorAll('cite[data-info]');
      const references = document.getElementById('citation-list');
    
      if (cites.length > 0) {
        let refContent = '<hr><h2>References</h2><ol>';
        
        cites.forEach((cite, index) => {
          const key = cite.getAttribute('key');
          const info = cite.getAttribute('data-info');
          refContent += `<li id="ref-${key}">${info}</li>`;
        });
    
        refContent += '</ol>';
        references.innerHTML = refContent;
      }
    });
  </script>

<div id="footnotes"></div>
<div id="citation-list"></div>

  <!-- Utterances Comments Script -->
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // Determine the current theme
      const theme = localStorage.getItem('theme') === 'dark' ? 'github-dark' : 'github-light';

      // Load the Utterances script with the determined theme
      const script = document.createElement('script');
      script.src = 'https://utteranc.es/client.js';
      script.setAttribute('repo', 'w3nhao/w3nhao.github.io');
      script.setAttribute('issue-term', 'pathname');
      script.setAttribute('theme', theme);
      script.setAttribute('crossorigin', 'anonymous');
      script.setAttribute('async', true);

      // Append the script to the container
      document.querySelector('.post').appendChild(script);
    });
  </script>
</div>



<div class="related">
  <h2>Related posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2026/02/06/Co-Evo-vs-Self-Evo/">
            Co-Evo vs Self-Evo
            <small>06 Feb 2026</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>


<!-- JavaScript to toggle TOC -->
<script>
  document.addEventListener('DOMContentLoaded', (event) => {
    const tocContainer = document.getElementById('toc-container');
    const toggleButton = document.getElementById('toggle-toc');

    toggleButton.addEventListener('click', () => {
      if (tocContainer.style.display === 'none') {
        tocContainer.style.display = 'block';
      } else {
        tocContainer.style.display = 'none';
      }
    });
  });

  document.addEventListener("DOMContentLoaded", function() {
    // Target only the <div> elements with the 'highlighter-rouge' class
    var codeBlocks = document.querySelectorAll('div.highlighter-rouge');
    
    codeBlocks.forEach(function(block) {
      var wrapper = document.createElement('div');
      var btn = document.createElement('button');
      
      // Extract language type from class
      var language = (block.className.match(/language-(\w+)/) || [,''])[1];
  
      btn.innerHTML = `<span class="description">Show/Hide Code</span><span class="language-type">${language}</span>`;
      btn.className = 'collapsible';
      
      block.parentNode.insertBefore(wrapper, block);
      wrapper.appendChild(btn);
      wrapper.appendChild(block);
      block.classList.add('collapsible_code_content');
    });
  
    // Same collapsible functionality as before:
    var coll = document.querySelectorAll(".collapsible");
    for (var i = 0; i < coll.length; i++) {
      coll[i].addEventListener("click", function() {
        this.classList.toggle("active");
        var content = this.nextElementSibling;
        if (content.style.maxHeight){
          content.style.maxHeight = null;
        } else {
          content.style.maxHeight = content.scrollHeight + "px";
        }
      });
    }
  });

</script>



      </div>
    </div>

    <!-- Bottom Navigation Bar -->
    <nav class="bottom-nav">
      <ul class="bottom-nav-links">
        <li><a href="/">~/home</a></li>
        <li><a href="/posts">~/posts</a></li>
        <li><a href="/life">~/gallery</a></li>
      </ul>
      <button class="theme-toggle" id="bottom-theme-toggle" aria-label="Toggle dark mode">dark</button>
    </nav>

    <!-- Your existing JavaScript -->
    <script src="/public/js/script.js"></script>
    
    <!-- Gallery functionality is in gallery-scripts.html include -->

    <!-- JavaScript for Dark Mode Toggle (Bottom Nav) -->
    <script>
      document.addEventListener('DOMContentLoaded', (event) => {
        const themeToggle = document.getElementById('bottom-theme-toggle');
      
        // Function to update Utterances theme
        function updateUtterancesTheme(theme) {
          const utterancesFrame = document.querySelector('.utterances-frame');
          if (utterancesFrame) {
            const message = {
              type: 'set-theme',
              theme: theme
            };
            utterancesFrame.contentWindow.postMessage(message, 'https://utteranc.es');
          }
        }
      
        // Initialize based on localStorage
        const currentTheme = localStorage.getItem('theme');
        if (currentTheme === 'dark') {
          document.documentElement.setAttribute('data-theme', 'dark');
          themeToggle.textContent = 'light';  // Show opposite (what it will switch TO)
          updateUtterancesTheme('github-dark');
        } else {
          themeToggle.textContent = 'dark';   // Show opposite (what it will switch TO)
          updateUtterancesTheme('github-light');
        }
      
        // Toggle theme on button click
        themeToggle.addEventListener('click', function () {
          const currentTheme = document.documentElement.getAttribute('data-theme');
          
          if (currentTheme === 'dark') {
            document.documentElement.setAttribute('data-theme', 'light');
            localStorage.setItem('theme', 'light');
            themeToggle.textContent = 'dark';   // Show what it will switch TO next
            updateUtterancesTheme('github-light');
          } else {
            document.documentElement.setAttribute('data-theme', 'dark');
            localStorage.setItem('theme', 'dark');
            themeToggle.textContent = 'light';  // Show what it will switch TO next
            updateUtterancesTheme('github-dark');
          }
        });
      });
    </script>
    
  </body>
</html>
